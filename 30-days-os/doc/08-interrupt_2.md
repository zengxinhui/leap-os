## 关于中断及设置-2
上一节我们说到中断的配置及跳转到的中断处理函数，我们上一节也留下了一个问题，就是操作系统是要如何才能产生一个中断向量呢？下边我们就来讲一下

### 中断设置知识储备
我们仔细想一下，当我们触发中断时，比如说键盘或者鼠标会把信号传递给CPU，CPU再产生中断号，然后去找中断处理函数。总结下就是外部设备传递信号给CPU，那么CPU肯定不会给每个外部设备分配一个接口。那么就会使用一个把所有的中断统一起来的外部设备，称为PIC(programmable interrupt controller)，可编程中断控制器。那么这个设备做了一些什么事情呢？这个设备就是负责把所有的中断信号接收，通过信号线发送给CPU（提供中断向量号）。如果同时产生很多中断，他也会维护一个队列，同时进行中断的优先级的判定。

我们代码中就是在bootpack.c的main函数处：
```
init_pic();
```
也就是说我们也对PIC进行一下设定，他才会发送给CPU中断号，进而去处理中断。

#### PIC
##### PIC芯片及信号线
我们来大致讲一下PIC吧，不然后边的代码会把大家搞晕。单独一个PIC芯片只有8个中断信号请求（IRQ<Interrupt ReQuest>）线:IRQ0~IRQ7，也就是说可以控制8个中断信号，这肯定是不够的，PIC采用了级联的方式来实现增加中断请求，如图所示：
图
我们个人电脑只有两个PIC芯片，通过主PIC芯片IRQ2连接从PIC芯片。每一个IRQ会代表一种类型的中断，比如说IRQ0是时钟中断，IRQ1是键盘...

##### PIC处理信号流程
除此之外，我们还需要看下PIC内部大体的构造，如图所示：
图
* INT:PIC芯片选择出来最高优先级中断请求，发送给CPU
* INTA: PIC芯片来接收CPU发来的中断响应信号
* IMR: Interrupt Mask Register, 中断屏蔽寄存器（8位），用来屏蔽来自外设的中断
* IRR: Interrupt Request Register, 中断请求寄存器（8位），保存经过IMR后等待处理的中断请求，相当于维护一个等待处理的中断队列
* PR: Priority Resoler, 优先级判别器，用来找出优先级最高的中断
* ISR: Interrupt Service Register, 中断服务寄存器（8位），保存正在被CPU出来的寄存器。
简单描述下原理：
当外设发出中断信号经过IRQ到达PIC内部时，首先到IMR处理，看IMR是否屏蔽了该IRQ的信号（IMR是8位(分别对应IRQ0~7)的寄存器，该位为1表示屏蔽）,如果屏蔽就丢弃这个信号，如果没有屏蔽信号进入到IRR(IRR也是8为寄存器，相应位为1则表示有该信号需要处理)保存。然后PR会从IRR中选择一个优先级最高的中断通过INT发送给CPU，当CPU处理完手头工作后会通过INTA发送给PIC芯片一个ack，然后PIC就会将ISR中相应的位置1，IRR中相应位置0，之后CPU会再次发送一个INTA信号给PIC（这里是CPU向PIC索要中断信号），PIC芯片会将初始中断向量号（后边讲到）+IRQ号发送给CPU，然后CPU就会执行相应的中断处理程序了。
那么当CPU处理完之后，如果PIC设置的EOI(End Of Interrupt)通知模式为手工模式，中断处理程序在结束处需要向PIC发送通知，PIC收到通知表示知道这个中断结束了。如果PIC设置EOI为自动模式，PIC在收到CPU索要中断向量号时就认为结束了，那么PIC认为结束时就会将ISR相应位置0，接着就等下一个中断来了。
##### PIC的设置寄存器



### 设置PIC


### 内存结构图