## 引导启动

### 引言
上一节我们讲了工程的结构和编译的流程，我们知道haribote是操作系统的代码文件夹，今天我们来讲述操作系统里的第一节，引导启动程序（ipl09），我们从源码角度来分析讲解下。

### 读取启动区之前
#### CPU的寻址空间
很久之前，intel的cpu 8086有20根地址线，能够访问的地址20位长，即2的20次方=1M，16进制表示的话0x00000到0xFFFFF。
所以cpu刚刚开机的时候能够访问的内存地址是1M，这个被称做实模式。CPU可以访问的1M地址并不是完全分给内存。
![image](https://user-images.githubusercontent.com/22785392/127582498-e7e03033-c5de-4fba-8cc9-fcad9e176d36.png)
如图，CPU的寻址空间0x00000～0x9FFFF(640K)是分给内存的，0xA0000~0xBFFFF(128K)是分给了显卡的，剩下的256K是分给了ROM里的BIOS。
我们经常会说到我的CPU的32位的那么寻址空间就是4G，但是这4G并不是完全分到内存，所以我们看到电脑会显示内存只使用了3.8G左右的原因了

#### 启动BIOS
上一个小节我们说到BIOS是放在ROM(只读存储器)中，ROM可以理解成一块断电后数据也不会丢失的存储空间。CPU的访问存储空间是用段地址+偏移地址来寻址。即CS:IP的形式去访问内存地址(这里内存不是完全指内存)，CS和IP都是寄存器的，关于寄存器这里也就不展开说了。实模式下寄存器的大小是16位，要访问到1M的地址空间，是段基址(CS)*16,也即CS的值左移4位，加上IP的值，那么就可以访问到1M了。<br/>
* 通电的瞬间，CPU的cs:ip被强制初始化为0xF000:0xFFF0，那么访问的地址就是0xFFFF0，这里便是BIOS的入口地址。然后BIOS的真正的代码也不是在这里，这里的代码也还是个跳转指令，跳转到0xFE05B<br/>
* 然后BIOS开始检测内存，显卡等硬件，当检测完成后，开始在0x000～0x3FF处建立数据结构等（这里后边说到）<br/>
* 最后BIOS去寻找启动盘的0盘0道1扇区的内容，即磁盘上最开始扇区。关于磁盘我也有篇文章讲到[磁盘](https://blog.csdn.net/leapmotion/article/details/118481004).检查这个扇区的最后两个字节是0x55和0xaa，便认为此扇区存在操作系统，便加载该扇区到0x7c00物理地址，然后跳转到该地址（jmp 0: 0x7c00）开始执行这里边的内容。

#### ipl程序
IPL(InitialProgram Loader), 在项目的文件是ipl09.nas，09表示都去9个柱面，这9个柱面就能装下一个操作系统了，9*2*18*512约为162KB，很小吧，作者也是很注重他的小巧，书中为了大小进行了多次优化（包括压缩）
从代码看起：
```
; leapos-ipl
; TAB=4
; 启动区512字节
; 计算器读写软盘的时候，并不是1字节的读写的，而是以512字节为单位读写，
; 因此软盘的512字节就称为一个扇区，一张软盘共有2880个扇区
; 第一个扇区称为启动区


CYLS   EQU  9      ; define 要读取的柱面个数
ORG  0x7c00     ; 程序要读到的位置
```

先看两行代码，这两行代码都是给编译器看的，并不会翻译成机器语言
* 'CYLS EQU 9'类似一个C语言#define语句，EQU即为equal，告诉编译器，CYLS这个变量是9, 当翻译成机器语言的时候CYLS变量都替换为9。
* 'ORG  0x7c00'，0x7c00是ipl程序加载到内存的地址，但是为什么要有一句ORG呢，其实ORG仅仅是告诉编译器我们的其实地址是0x7c00。

```
; 以下是标准FAT12格式软盘的描述
    JMP  entry      ; JMP无条件跳转
	DB   0x90       ; define byte, 填充一个字节
	DB   "LEAPIPL " ; 启动区的名称(必须是8字节), ipl(initial program loader)
	DW   512        ; define word=2*DB,每个扇区的大小必须是512
	DB   1          ; 簇的大小(必须是1个扇区)
	DW   1          ; FAT的起始位置(一般是第1个扇区)
	DB   2          ; FAT的个数（必须是2）
	DW	 224		; 根目录的大小(一般设成224项)
	DW	 2880		; 该磁盘的大小（必须是2880扇区）
	DB	 0xf0		; 磁盘的种类（必须是0xf0）
	DW	 9			; FAT的长度（必须是9扇区）
	DW	 18			; 1个磁道（track）有几个扇区（必须是18）
	DW	 2			; 磁头数（必须是2）
	DD	 0			; 不使用分区，必须是0，define double word=2*DW
	DD	 2880		; 重写一次磁盘大小
	DB	 0,0,0x29		; 意义不明，固定
	DD	 0xffffffff		; （可能是）卷标号码
	DB	 "LEAP-OS    "	; 磁盘的名称（必须是11字节）
	DB	 "FAT12   "		; 磁盘格式名称（必须是8字节）
	RESB 18				; 空出18字节
```
这一下指令有点多，'JMP entry'是机器语言的第一条指令。本书的启动盘是软盘，和我们平常说的硬盘启动还有一些不一样，一个单磁盘的硬盘，它拥有80个柱面（0-79），2个磁头（正反面，0-1），18个扇区（1-18），总的大小就是80×2×18×512=1474560Byte=1440KB，所以也能看到我们最后img大小就是1440KB。
继续程序这里，首先cpu会读取软盘的前77个字节来判断软盘类型，上边FAT12格式的软盘的前77个字节的描述。而最重要的时第一条，即程序的第一条指令。注释已经说明了每个字节的说明，或者说这些都是规定。

```
; 程序主体
entry:
	MOV  AX,0
	MOV  SS,AX
	MOV  SP,0x7c00
	MOV  DS,AX

; 软盘共有80个柱面，2个磁头，每个柱面18个扇区，每个扇区512字节
; 读磁盘CYLS(9)个柱面的数据到0x08200～0x30a00
; IPL的启动区，位于C0-H0-S1（柱面0，磁头0，扇区1的缩写）
; 指定内存的地址，必须同时指定段寄存器，如果省略DS作为默认的段寄存器
	MOV  AX,0x0820
	MOV  ES,AX      ; 指定[ES:BX]为读取的位置，加载到ES*16+BX=0x8200位置
	MOV  CH,0       ; 柱面0
	MOV  DH,0       ; 磁头0
	MOV	 CL,2		; 扇区2
	MOV  BX,18*2*CYLS-1 ; 要读取的合计扇区
	CALL readfast   ; 调用读取
```

我们到程序的入口，进行一些初始化的工作，然后指定了要读取的内容到地址0x8200，总共要读取的扇区是18*2*CYLS再减去我们正在使用的第一个扇区，然后我们调用readfast函数进行读取操作。

```
readfast:      ;使用AL尽量一次性读取数据
; ES: 读取地址   CH:柱面  DH:磁头  CL:扇区  BX:读取的扇区

	MOV		AX,ES			; < 通过ES计算AL最大值 >
	SHL		AX,3			; AX除以32，结果存入AH
	AND		AH,0x7f			; AH是AH除以128所得的余数（512*128=64K）
	MOV		AL,128			; AL = 128 - AH; AH是AH除以128所得的余数（512*128=64K）
	SUB		AL,AH

	MOV		AH,BL			; < 通过BX计算AL的最大值存入AH >
	CMP		BH,0			; if (BH != 0) { AH = 18; }
	JE		.skip1
	MOV		AH,18
```
到readfast函数这里我们看下
