## 引导启动

### 引言
上一节我们讲了工程的结构和编译的流程，我们知道haribote是操作系统的代码文件夹，今天我们来讲述操作系统里的第一节，引导启动程序（ipl09），我们从源码角度来分析讲解下。

### 读取启动区之前
#### CPU的寻址空间
很久之前，intel的cpu 8086有20根地址线，能够访问的地址20位长，即2的20次方=1M，16进制表示的话0x00000到0xFFFFF。
所以cpu刚刚开机的时候能够访问的内存地址是1M，这个被称做实模式。CPU可以访问的1M地址并不是完全分给内存。
![image](https://user-images.githubusercontent.com/22785392/127582498-e7e03033-c5de-4fba-8cc9-fcad9e176d36.png)
如图，CPU的寻址空间0x00000～0x9FFFF(640K)是分给内存的，0xA0000~0xBFFFF(128K)是分给了显卡的，剩下的256K是分给了ROM里的BIOS。
我们经常会说到我的CPU的32位的那么寻址空间就是4G，但是这4G并不是完全分到内存，所以我们看到电脑会显示内存只使用了3.8G左右的原因了

#### 启动BIOS
上一个小节我们说到BIOS是放在ROM(只读存储器)中，ROM可以理解成一块断电后数据也不会丢失的存储空间。CPU的访问存储空间是用段地址+偏移地址来寻址。即CS:IP的形式去访问内存地址(这里内存不是完全指内存)，CS和IP都是寄存器的，关于寄存器这里也就不展开说了。实模式下寄存器的大小是16位，要访问到1M的地址空间，是段基址(CS)*16,也即CS的值左移4位，加上IP的值，那么就可以访问到1M了。<br/>
* 通电的瞬间，CPU的cs:ip被强制初始化为0xF000:0xFFF0，那么访问的地址就是0xFFFF0，这里便是BIOS的入口地址。然后BIOS的真正的代码也不是在这里，这里的代码也还是个跳转指令，跳转到0xFE05B<br/>
* 然后BIOS开始检测内存，显卡等硬件，当检测完成后，开始在0x000～0x3FF处建立数据结构等（这里后边说到）<br/>
* 最后BIOS去寻找启动盘的0盘0道1扇区的内容，即磁盘上最开始扇区。关于磁盘我也有篇文章讲到[磁盘](https://blog.csdn.net/leapmotion/article/details/118481004).检查这个扇区的最后两个字节是0x55和0xaa，便认为此扇区存在操作系统，便加载该扇区到0x7c00物理地址，然后跳转到该地址（jmp 0: 0x7c00）开始执行这里边的内容。

#### ipl程序
