## 实模式切换到保护模式

### 前言
上节课我们讲了启动区读取整个操作系统和应用程序到内存中，并且跳转到操作系统开始的程序，这里我们都是在实模式下进行，内存访问也才1M，寄存器大小大都是16位宽，且CPU也并不提供保护机制，所以我们需要切换到保护模式下，也可以更好的使用C语言来编写程序。

### 知识储备
#### 内存分段
**寄存器**<br>
讲内存分段前我们先简单说一下寄存器，一般来说寄存器分为两个大的类别，段寄存器和通用寄存器
通用寄存器：
```
AX——accumulator，累加寄存器
CX——counter，计数寄存器
DX——data，数据寄存器
BX——base，基址寄存器
SP——stack pointer，栈指针寄存器
BP——base pointer，基址指针寄存器
SI——source index，源变址寄存器
DI——destination index，目的变址寄存器
```
这些寄存器可以在运算过程中使用，都是16位的<br>
AX, BX, CX, DX又可以分为两个高低位的寄存器，例如AX可以分为AH,AL。AH指向的时AX高8位，AL指向的时AX的低8位。

段寄存器：
```
ES——附加段寄存器（extra segment）
CS——代码段寄存器（code segment）
SS——栈段寄存器（stack segment）
DS——数据段寄存器（data segment）
FS——没有名称（segment part 2）
GS——没有名称（segment part 3）
```
这些是段寄存器，这些的用处一般用于段寻址的时候。<br>
这里的段寄存器和通用寄存器都是16宽，也就是在实模式下使用的寄存器都是16宽。32位宽的寄存器需要在这些前边加一个E, EAX, EBX等等，我们切换到保护模式便可以使用32位宽的寄存器。64位宽的寄存器是在前边加一个R，RAX，RBX等等，作者书中并没有涉及到64位的寄存器，这里也不再多说。

**数据段和代码段**<br>
什么是内存分段呢？其实就是内存中划分为一段一段的空间，我们前边学习到使用[CS:IP]的方式去读取内存的指令，同样BIOS读取磁盘到指定内存空间时是使用[ES:BX]来表示。这些都是我们去访问内存的方式，具体来说CS这个寄存器的值表示的段的开始位置，也称为段基址，IP这个指向段内的偏移地址，这样就可以取到相应的指令。
举个例子来说：<br>
<img src="https://user-images.githubusercontent.com/22785392/129821580-b5a36973-8f55-41da-b978-e8e58131f99b.png" width="30%" height="30%"/>
如图所示，一个程序的代码段和数据段放置在内存的不同位置，这个程序的代码段起始位置是0xFF000，那么如果要读取代码段的代码该如何执行呢，我们可以将CS设置为0xFF00，同时设置IP为某个偏移位置，那么获取到的指令的位置就是[CS:IP]表示，在实模式下即为CS*16+IP。同理CPU如果访问数据段的数据该如何定位呢，比如说 "MOV [0x100] 1" 设置内存中0x100的值为1，那么我们其实已经设置了DS为0xFA00，然后CPU就会去计算DS*16+0x100位置(实模式下)设置1，数据段中没有一个寄存器来表示偏移，只有一个数据段基地址寄存器。<br>
因为实模式下20位的内存总线，但是只有16位寄存器，所以需要将段基址*16加上偏移地址。保护模式下的段寻址后边再补充下。

这里要提一下是，上一节我们讲到了启动开机时，cs:ip会被设置为0xF000:0xFFF0，ds寄存器没有被设置（即为0），且我们上一节的启动程序也只有代码段。

#### 实模式和保护模式对比

实模式下只能寻址到1M大小，C语言程序编译成16位的比较麻烦。调用BIOS实现硬件访问
保护模式因为地址总线有32位宽，2^32=4G大小的内存，c语言很容易编译成32位的，可以直接使用C语言编程。无需调用BIOS实现硬件访问。


### 代码跟踪


### 总结
