## 实模式切换到保护模式-1

### 前言
上节课我们讲了启动区读取整个操作系统和应用程序到内存中，并且跳转到操作系统开始的程序，这里我们都是在实模式下进行，内存访问也才1M，寄存器大小大都是16位宽，且CPU也并不提供保护机制，所以我们需要切换到保护模式下，也可以更好的使用C语言来编写程序。

### 知识储备
#### 内存分段
**寄存器**<br>
讲内存分段前我们先简单说一下寄存器，一般来说寄存器分为两个大的类别，一类是CPU内部使用的，一类是对程序员可见的寄存器，对程序员可见的寄存器大概也可以分为两类：通用寄存器和段寄存器。
段寄存器和通用寄存器
通用寄存器：
```
AX——accumulator，累加寄存器
CX——counter，计数寄存器
DX——data，数据寄存器
BX——base，基址寄存器
SP——stack pointer，栈指针寄存器
BP——base pointer，基址指针寄存器
SI——source index，源变址寄存器
DI——destination index，目的变址寄存器
```
这些寄存器可以在运算过程中使用，都是16位的<br>
AX, BX, CX, DX又可以分为两个高低位的寄存器，例如AX可以分为AH,AL。AH指向的时AX高8位，AL指向的时AX的低8位。

段寄存器：
```
ES——附加段寄存器（extra segment）
CS——代码段寄存器（code segment）
SS——栈段寄存器（stack segment）
DS——数据段寄存器（data segment）
FS——没有名称（segment part 2）
GS——没有名称（segment part 3）
```
这些是段寄存器，这些的用处一般用于段寻址的时候。<br>
这里的段寄存器和通用寄存器都是16宽，也就是在实模式下使用的寄存器都是16宽。32位宽的寄存器需要在这些前边加一个E, EAX, EBX等等，我们切换到保护模式便可以使用32位宽的寄存器。64位宽的寄存器是在前边加一个R，RAX，RBX等等，作者书中并没有涉及到64位的寄存器，这里也不再多说。

**数据段和代码段**<br>
什么是内存分段呢？其实就是内存中划分为一段一段的空间，我们前边学习到使用[CS:IP]的方式去读取内存的指令，同样BIOS读取磁盘到指定内存空间时是使用[ES:BX]来表示。这些都是我们去访问内存的方式，具体来说CS这个寄存器的值表示的段的开始位置，也称为段基址，IP这个指向段内的偏移地址，这样就可以取到相应的指令。
举个例子来说：<br>
<img src="https://user-images.githubusercontent.com/22785392/129821580-b5a36973-8f55-41da-b978-e8e58131f99b.png" width="30%" height="30%"/>
如图所示，一个程序的代码段和数据段放置在内存的不同位置，这个程序的代码段起始位置是0xFF000，那么如果要读取代码段的代码该如何执行呢，我们可以将CS设置为0xFF00，同时设置IP为某个偏移位置，那么获取到的指令的位置就是[CS:IP]表示，在实模式下即为CS\*16+IP。同理CPU如果访问数据段的数据该如何定位呢，比如说 "MOV [0x100] 1" 设置内存中0x100的值为1，那么我们其实已经设置了DS为0xFA00，然后CPU就会去计算DS\*16+0x100位置(实模式下)设置1，数据段中没有一个寄存器来表示偏移，只有一个数据段基地址寄存器。<br>
因为实模式下20位的内存总线，但是只有16位寄存器，所以需要将段基址\*16加上偏移地址。保护模式下的段寻址后边再补充下。
这里要提一下是，上一节我们讲到了启动开机时，cs:ip会被设置为0xF000:0xFFF0，ds寄存器没有被设置（即为0），且我们上一节的启动程序也只有代码段。

#### 实模式和保护模式对比
实模式或者保护模式是CPU的工作环境，具体体现在寻址方式，寄存器的大小，指令用法等等方面。CPU中本来没有实模式一称的，但是有了保护模式之后，为了做区分就有了实模式的说法。<br>

**实模式**的“实”其实就是说程序中用到的地址都是真实的物理地址。实模式下只能寻址到1M大小，寄存器大小只能是16位，C语言程序编译成16位的比较麻烦。调用BIOS实现硬件访问<br>，安全性方面：1)实模式下操作系统和用户程序属于同一特权级，并没有区分. 2)用户程序可以修改段基址，这样就可以访问内存中所有空间

**保护模式**的关键字当然是保护，保护模式有一些机制针对内存段等做一些保护措施。因为地址总线有32位宽，2^32=4G大小的内存，另外c语言很容易编译成32位的，可以直接使用C语言编程。无需调用BIOS实现硬件访问。<br>
同样也是为了安全, CPU对内存的访问并不是像实模式直接访问到，增加一个数据结构，名字叫做**全局描述符表（Global Descriptor Table，GDT）**，这个表存放在内存中，听名字是一个表，那么肯定有很多表项，每一项被称为段描述符，大小为64字节，那么每个表项里边放的是什么呢，存放的时用来描述各个内存段的起始地址，大小权限等信息。全局描述符表的起始地址存放在CPU中的一个寄存器(**GDTR**)中(48位的寄存器)。这样来说，段寄存器存放的就不是段基址了，而是存放的“**选择子**”，这个选择子是个什么概念呢，大家其实可以把全局描述符表理解成一个数组，数据元素是段描述符，选择子就是执行某一个段描述符的数组index。

我们再通过一个图来认识下段描述符：<br>
<img src="https://user-images.githubusercontent.com/22785392/130305104-4b220db8-a66c-4008-b5d8-2f1373775ead.png" width="80%" height="80%"/>

从图中我们可以看到，CPU通过段寄存器和GDTR可以定位到段描述符，这里段寄存器还是只是使用16位的，然后看到段描述符的各项说明。
* 首先分为高32位和低32位
* 段基址由高32位的31～24，7～0，低32位的31～16组合提供
* 段界限是说这个段的边界，用这个值来表示段内偏移的最大值
* 高地址的8～11位（共4位）是type字段和12位的S字段共同指定本描述符的类型，即系统段和非系统段（S指定），非系统段又分为数据段，代码段（type来执行）等等。这里凡事硬件运行需要用到的东西称为系统段，软件需要的东西称为非系统段。针对非系统段来说TYPE同样会标识这个段是否可读可写可访问等权限。
* 14～13位，DPL（Descriptor Privilege Level）描述符特权级，这也是保护模式提供的安全解决方案，从0到3，数字越小权限越大。
* 15位P（Present）表示内存中是否存在该段
* 20位AVL预留位
* 21位L表示是否是64位代码段，我们在32位下编程，这里置为0即可
* 22位D/B用来指示有效地址和操作数的大小，这里用处是为了向下兼容，不细讲
* 23位G（Granularity，粒度），表示的是段界限的单位，如果此位是0，表示单位是1字节，这个段的界限就是20次方\*1字节=1M。如果此位是1表示单位是4KB，那么就是20次方\*4KB=4G

### 总结
本文章讲解了实模式下的内存分段，以及各寄存器的大小和类型，继而我们又讲了关于实模式和保护模式的一些对比。下一讲我们就来分析下代码。

